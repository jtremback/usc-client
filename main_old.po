package main

import (
	"fmt"
	"github.com/boltdb/bolt"
	"github.com/codegangsta/cli"
	"github.com/jtremback/upc/wallet/logic"
	"os"
)

func main() {
	app := cli.NewApp()
	app.Name = "upc"
	app.Usage = "universal payment channels cli"

	pathFlag := cli.StringFlag{
		Name:  "dbpath",
		Usage: "Path of the database to use.",
	}

	app.Commands = []cli.Command{
		{
			Name:  "new",
			Usage: "make new stuff",
			Subcommands: []cli.Command{
				{
					Name:  "channel",
					Usage: "make a new channel",
					Flags: []cli.Flag{
						pathFlag,
						cli.StringFlag{
							Name:  "a, account",
							Usage: "Name of the account to use for this channel.",
						},
						cli.StringFlag{
							Name:  "p, peer",
							Usage: "Name of peer to open the channel with.",
						},
						cli.StringFlag{
							Name:  "m, mybalance",
							Usage: "The amount of money you're putting in the channel.",
						},
						cli.StringFlag{
							Name:  "t, theirbalance",
							Usage: "The amount of money the peer will put in the channel.",
						},
						cli.StringFlag{
							Name:  "h, holdperiod",
							Usage: "The duration of the hold period.",
						},
					},
					Action: func(c *cli.Context) {
						newChannel()
					},
				},
			},
		},
		{
			Name:  "send",
			Usage: "send money on a channel",
			Flags: []cli.Flag{
				cli.StringFlag{
					Name:  "c, channel",
					Usage: "ChannelID of the channel to send on. Cannot be used together with --peer.",
				},
				cli.StringFlag{
					Name:  "p, peer",
					Usage: "Name of peer to send to (if you only have one channel open with them). Cannot be used together with --channel.",
				},
				cli.StringFlag{
					Name:  "a, amount",
					Usage: "the amount to be sent on the channel",
				},
			},
			Action: func(c *cli.Context) {
				fmt.Println(c.String("p"))
				// newDB(c.String("p"))
			},
		},
	}

	app.Run(os.Args)
}

func newChannel(acct string, peer string, myAmount string, theirAmount string, holdPeriod string) {
	db, err := bolt.Open(path, 0600, nil)
	if err != nil {
		fmt.Println(err)
	}

	logic.NewChannel(acct, peer, m, t, h)

	// Retrieve
}

// func newDB(path string) {
// 	// db, err := bolt.Open(path, 0600, nil)
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// 	defer db.Close()

// 	err = db.Update(func(tx *bolt.Tx) error {
// 		b := tx.Bucket([]byte("MyBucket"))
// 		return nil
// 	})
// 	if err != nil {
// 		log.Fatal(err)
// 	}
// }
